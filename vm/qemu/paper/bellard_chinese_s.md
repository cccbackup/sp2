# QEMU，一个快速和可移植的动态翻译

> Fabrice Bellard

## 文摘

我们介绍了QEMU的内部结构，这是一个使用原始可移植动态转换器的快速机器仿真器。它在多个主机(x86、PowerPC、ARM和Sparc)上仿真多个cpu (x86、PowerPC、ARM、Sparc、Alpha和MIPS)。QEMU支持完整的系统仿真，即在虚拟机中运行完整且未修改的操作系统，在Linux用户模式仿真中，为一个目标CPU编译的Linux进程可以在另一个CPU上运行。

## 1 介绍

QEMU是一个机器仿真器:它可以在虚拟机中运行未经修改的目标操作系统 (如Windows或Linux) 及其所有应用程序。QEMU本身运行在多个主机操作系统上，如 Linux、Windows 和 Mac OS x。主机和目标 cpu 可以不同。

QEMU 的主要用途是在另一个操作系统上运行一个操作系统，比如 Linux 上的 Windows 或 Windows 上的Linux。 另一种用法是调试，因为可以轻松地停止虚拟机，并且可以检查、保存和恢复虚拟机的状态。此外，可以通过添加新的机器描述和新的模拟设备来模拟特定的嵌入式设备。

QEMU 还集成了一个 Linux 特定的用户模式模拟器。它是机器仿真器的一个子集，在另一个CPU上为一个目标CPU运行 Linux 进程。它主要用于测试跨编译器的结果或测试CPU 模拟器，而不必启动一个完整的虚拟机。

QEMU 由几个子系统组成:

* CPU 仿真器 (目前为 x86 [註1], PowerPC, ARM 和Sparc)
* 模拟设备(如 VGA 显示器、16450 串口、PS/2 鼠标键盘、IDE 硬盘、NE2000 网卡，…)
* 用于将模拟设备连接到相应主机设备的通用设备(例如块设备、字符设备、网络设备)
* 实例化仿真设备的机器描述(如PC、PowerMac、Sun4m)
* 调试器
* 用户界面

本文研究 QEMU 使用的动态转换器的实现。动态转换器执行目标CPU指令到主机指令集的运行时转换。产生的二进制代码存储在转换缓存中，以便可以重用。与解释器相比，它的优点是只获取和解码目标指令一次。

通常，动态翻译器很难从一个主机移植到另一个主机，因为整个代码生成器必须重写。它花費的工作量与向 C 编译器添加新目标的工作量大致相同。 QEMU 要简单得多，因为它只是将 GNU C 编译器[5] 离线生成的机器码片段连接起来。

CPU模拟器还面临其他更经典但更困难的[2] 问题:

* 翻译代码缓存的管理
* 寄存器分配
* 条件代码优化
* 直接块链接
* 内存管理
* 自修改代码支持
* 例外支持
* 硬件中断
* 用户模式模拟

## 2 可移植的动态翻译

### 2.1 描述

第一步是将每个目标 CPU 指令分割成更少的称为微操作的更简单的指令。每个微操作都是由一小段 C 代码实现的。这个小 C 源代码由 GCC 编译成一个目标文件。选择微操作是为了使它们的数目比所有指令和操作数的组合小得多(通常是几百个) 。从目标CPU指令到微操作的转换完全是用手工编码完成的。源代码经过了可读性和紧凑性的优化，因为这一阶段的速度没有解释器那么重要。

一个名为 dyngen 的编译时期工具使用包含微操作的目标文件作为输入来生成动态代码。这个动态代码生成器在运行时被调用，以生成一个连接多个微操作的完整主机函数。

这个过程类似于[1]，但是为了获得更好的性能，需要在编译时做更多的工作。特别是，一个关键的思想是，QEMU 在微操作可以給予常數。为此，使用 GCC 为每个常数生成伪代码重新定位。这使 dyngen 工具能够定位重定位并生成适当的 C 代码，以便在构建动态代码时解决它们。还支持重定位，以支持对静态数据和微操作中的其他函数的引用。

### 2.2的例子

考虑这样一种情况，我们必须将以下 PowerPC 指令转换为 x86 代码:

```
addi r1,r1，-16     # r1 = r1 -16
```

以下微操作是由 PowerPC 代码转换器生成的:

```
movl_T0_r1         # T0 = r1
addl_T0_im -16     # T0 = T0 - 16
movl_r1_T0         # r1 = T0
```

在不影响生成代码质量的情况下，最小化了微操作的数量。

例如，我们不是在每 32 个 PowerPC 寄存器之间生成所有可能的移动，而是生成到几个临时寄存器的移动和从临时寄存器的移动。这些寄存器T 0、T1、T2 通常通过使用 GCC 静态寄存器变量扩展存储在主机寄存器中。

微操作 movl T0 r1 一般编码为:

```c
void op_movl_T0_r1(void)
{
  T0 = env->regs[1];
}
```

env是一个包含目标CPU状态的结构。

32 个 PowerPC 寄存器存储在数组中

```
env->regs[32].
```

addl T0 im 更有趣，因为它使用了一个常量参数，其值是在运行时确定的:

```c
extern int __op_param1;
void op_addl_T0_im(void)
{
  T0 = T0 + ((long)(&__op_param1));
}
```

dyngen 生成的代码生成器采用 opc_ptr 指向的微操作流，并输出主机代码在位置 gen_code_ptr。微操作参数由 opparam_ptr 指定:

```c
[...]
for(;;) {
  switch(*opc_ptr++) {
    [...]
    case INDEX_op_movl_T0_r1:
    {
      extern void op_movl_T0_r1();
      memcpy(gen_code_ptr, (char *)&op_movl_T0_r1+0, 3);
      gen_code_ptr += 3;
      break;
    }
    case INDEX_op_addl_T0_im:
    {
      long param1;
      extern void op_addl_T0_im();
      memcpy(gen_code_ptr, (char *)&op_addl_T0_im+0, 6);
      param1 = *opparam_ptr++;
      *(uint32_t *)(gen_code_ptr + 2) = param1;
      gen_code_ptr += 6;
      break;
    }
    [...]
    }
  }
  [...]
}
```

对于大多数微操作，例如 movl T0 r1，只复制 GCC 生成的主机代码。当使用常数参数时，dyngen 使用的事实是 GCC 生成对 op_param1 的重定位，用运行时参数 (这里称为 param1) 修补生成的代码。

当代码生成器运行时，输出以下主机代码:

```
# movl_T0_r1
# ebx = env->regs[1]
mov 0x4(%ebp),%ebx

# addl_T0_im -16
# ebx = ebx - 16
add $0xfffffff0,%ebx

# movl_r1_T0
# env->regs[1] = ebx
mov %ebx,0x4(%ebp)
```

在 x86上，T0 映射到 ebx 寄存器，而 CPU 状态上下文映射到 ebp 寄存器。

## 2.3 Dyngen实现

dyngen 工具是 QEMU 转换过程的关键。在包含微操作的对象文件上运行时执行以下任务:

* 对目标文件进行解析，获取其符号表、重定位项和代码段。此传递取决于主机对象文件格式 (dyngen 支持 ELF (Linux)、PE-COFF (Windows)和MACH-O (Mac OS X))。
* 微操作位于代码段部分，並且使用符号表。宿主机有一個函數可以取得开始和结束點。通常，函数『序言和尾声』被跳过。
* 对每个微操作的重新定位进行检查，以获得常数参数的数量。常量参数重定位是通过使用特定的符号名称 op_paramN 来检测的。
* 生成一个 C 语言的内存拷贝来拷贝微操作代码。每个微操作的代码的重新定位用于对复制的代码进行修补，以便对其进行适当的重新定位。重新定位补丁是特定于主机的。
* 对于一些主机，如 ARM ，常量必须存储在生成的代码附近，因为它们是通过PC的相对负载以较小的位移访问的。在生成的代码中执行主机特定的步骤来重新定位这些常量。

在编译微代码时，使用一组 GCC 标志将函数『序言和尾声』代码的生成操作为易于解析的形式。一个虚拟装配宏迫使 GCC 总是终止对应于每个微处理器的函数使用单个返回指令进行操作。 （A dummy assembly macro forces GCC to always terminate the function corresponding to each micro operation with a single return instruction.）如果在单个微操作中生成多个返回指令，则代码连接将不起作用。

## 3实现细节

### 3.1 翻译块和翻译缓存

当 QEMU 第一次遇到一段目标代码时，它会将其转换为主机代码，直到下一次跳转或修改静态 CPU 状态的指令，而这在转换时是无法推导出来的。我们称之为翻译块 (TBs)。

一个 16 MB 的缓存保存最近使用的 TBs。为简单起见，它在满的时候被完全刷新。

静态 CPU 状态被定义为输入 TB 时在转换时被认为是已知的CPU状态的一部分。例如，程序计数器 (PC) 在所有目标上的翻译时都是已知的。在 x86 上，静态 CPU 状态包含更多的数据，以便能够生成更好的代码。例如，了解 CPU 是处于受保护模式还是实际模式、用户模式还是内核模式、或者默认的操作数大小是 16 位还是 32 位是很重要的。

### 3.2 寄存器分配

QEMU 使用固定的寄存器分配。这意味着每个目标 CPU 寄存器都映射到一个固定的主机寄存器或内存地址。在大多数主机上，我们简单地将所有目标寄存器映射到内存，只在主机寄存器中存储一些临时变量。的分配临时变量硬编码在每个目标 CPU 描述中。这种方法的优点是简单和可移植性。

QEMU 的未来版本将使用动态临时寄存器分配器来消除目标寄存器直接存储在主机寄存器中的一些不必要的移动。

### 3.3 条件代码优化

良好的 CPU 条件代码仿真 (x86上的eflags寄存器) 是获得良好性能的关键。

QEMU使用惰性条件代码计算:它只存储一个操作数(称为 CC_SRC)、结果(称为CC_DST)和操作类型(称为CC_OP)，而不是在每个 x86 指令之后计算条件代码。对于一个32位的加法，比如 R = A + B，我们有:

```
CC_SRC=A
CC_DST=R
CC_OP=CC_OP_ADDL
```

知道我们从 CC_OP 中存储的常量中添加了 32 位，我们可以从CC_SRC 和 CC_DST 中恢复 A、B 和 R。然后，如果下一个指令需要，那么所有相应的条件代码，如零结果 (ZF)、非正结果(SF)、进位(CF) 或溢出(OF) 都可以被恢复。

通过使用一次生成一个完整 TB 的代码这一事实，在翻译时进一步优化条件代码评估。对生成的代码执行向后传递，以查看以下代码是否使用了 CC_P、CC_SRC 或 CC_DST。结束时对于TB，我们考虑使用这些变量。然后删除值在以下代码中不使用的赋值。

### 3.4 直接块链接

在执行每个TB之后，QEMU使用模拟程序计数器(PC) 和静态CPU状态的其他信息，使用散列表查找下一个 TB。如果下一个 TB 还没有被翻译，则启动一个新的翻译。否则，将跳转到下一个 TB。

为了加速新模拟 PC 已知的最常见情况(例如在条件跳转之后)，QEMU可以修补一个 TB，使其直接跳转到下一个。

最可移植的代码使用间接跳转。在某些主机上(如x86或PowerPC)，直接修补分支指令，这样块链接就没有开销。

#### 3.5 内存管理

对于系统仿真，QEMU 使用 mmap() 系统调用来仿真目标 MMU。只要模拟的 OS 不使用主机 OS [註2] 保留的区域，它就可以工作

为了能够启动任何操作系统，QEMU 还支持一个软件 MMU。在这种模式下，MMU 虚拟地址到物理地址的转换是在每次访问内存时完成的。QEMU 使用地址转换缓存来加速转换。

为了避免在每次 MMU 映射更改时刷新已翻译的代码，QEMU使用物理索引的翻译缓存。这意味着每个TB都用它的物理地址进行索引。

当 MMU 映射改变时，TBs 的链接被重置(即一个TB不能再直接跳转到另一个TB)，因为跳转目标的物理地址可能会改变。

### 3.6 自修改代码和翻译代码失效

在大多数 cpu上，自修改代码很容易处理，因为会执行特定的代码缓存失效指令来表示代码已经修改。它足以使相应的翻译代码无效。

但是在 x86 这样的 cpu上，当代码被修改时，应用程序不会发出指令缓存失效的信号，因此自修改代码是一个特殊的挑战 [註3]。

当为 TB 生成翻译后的代码时，如果相应的主机页不是只读的，那么它将被写保护。如果对页面进行了写访问，那么 QEMU 将使其中的所有翻译代码无效，并重新启用对其的写访问。通过维护给定页面中包含的每个已翻译块的链接列表，可以有效地完成正确的翻译代码失效。还维护了其他链表来撤消直接块链接。

当使用软件 MMU 时，代码失效会更有效:如果给定的代码页由于写访问而频繁失效，那么就会构建一个位图来表示页面内的所有代码。进入该页面的每个存储都将检查位图，以确定代码是否真的需要作废。它避免了仅在某些情况下才使代码无效在页面中修改数据。

### 3.7 异常支持

longjmp()用于在遇到除0之类的异常时跳转到异常处理代码。当不使用软件 MMU 时，使用主机信号处理程序来捕获无效的内存访问。

QEMU 支持精确异常，因为它总是能够在异常发生时检索精确的目标CPU 状态。没有什么需要做的大部分的目标 CPU 状态，因为它是显式存储和修改的翻译代码。没有显式存储的目标 CPU 状态(例如当前程序计数器)是通过重新翻译TB来检索的，在这种模式中，异常发生在每条被翻译的目标指令之前的S被记录。的引发异常的主机程序计数器用于查找相应的目标指令和状态S。

#### 3.8 硬件中断

为了更快，如果一个硬件中断正在等待，QEMU不会检查每个 TB。相反，用户必须异步调用一个特定的函数来通知中断正在等待。此函数重置当前执行的 TB 的链接。它确保在 CPU 模拟器的主循环中执行将很快返回。然后主循环测试一个中断是否挂起并处理它。

#### 3.9 用户模式模拟

QEMU支持用户模式模拟，以便在另一个 CPU 上运行为一个目标CPU 编译的 Linux 进程。

在 CPU 级别，用户模式模拟只是整个系统模拟的一个子集。没有进行MMU模拟，因为QEMU假设用户内存映射由主机 OS 处理。QEMU包含一个通用的 Linux 系统调用转换器，用于处理 endianness 问题和 32/64 位转换。因为 QEMU 支持异常，所以它可以精确地模拟目标信号。每个目标线程在一个主机thread [註5] 中运行。

## 4 移植工作

为了将 QEMU 移植到新的主机 CPU，必须执行以下操作:

* dyngen 必须被移植(见2.2节)。
* 微操作使用的临时变量可以映射到主机的特定寄存器中以优化性能。
* 大多数主机 cpu 需要特定的指令来保持指令之间的一致性缓存和内存。
* 如果直接块链接是用修补的分支指令，一些特定的汇编宏必须提供。

估计了 QEMU 的整体移植复杂性与动态链接器相同。

## 5 性能

为了度量仿真带来的开销，我们比较了 BYTEmark 基准测试在x86 主机上本机模式下的性能，以及在 x86 目标用户模式仿真下的性能。

用户模式 QEMU(版本0.4.2) 的速度比 integer 代码上的本机代码慢 4 倍左右。

对于浮点代码，它要慢 10 倍。这可以理解为在静态 CPU 状态下缺少 x86 FPU 堆栈指针的结果。在全系统仿真中，软件 MMU 的成本降低了2倍。

在整个系统仿真中，QEMU的速度大约是Bochs[4] 的30倍。

用户模式 QEMU 比 `valgrind -skin=none` 快 1.2 倍版本1.9.6[6]，一个手动编码的从 x86 到 x86 的动态转换器，通常用于调试程序。-skin=none 选项确保 valgrind 不会生成调试代码。

## 结论和未来的工作

QEMU 已经达到了可以在日常工作中使用的程度，特别是对于Windows 等商业 x86 操作系统的仿真。PowerPC 目标已经接近为了启动 Mac OS X, Sparc 开始启动 Linux。迄今为止，还没有其他动态转换器能够在如此多的主机上支持如此多的目标，这主要是因为移植的复杂性被低估了。QEMU 方法似乎是性能和复杂性之间的一个很好的折衷。

今后仍需解决以下问题:

* 移植:QEMU在PowerPC和x86主机上得到了很好的支持。Sparc、Alpha、ARM和MIPS上的其他端口需要打磨。QEMU还在很大程度上依赖于用于编译微操作定义的准确GCC版本。
* 完整的系统仿真:需要添加ARM和MIPS目标。
* 性能:可以提高软件MMU的性能。一些关键的微操作也可以在汇编语言中手工编码，而不需要在当前的翻译框架中做太多的修改。CPU主循环也可以用汇编语言手工编码。
* 虚拟化:当主机和目标相同时，可以按原样运行大部分代码。最简单的实现是照常模拟目标内核代码，但按原样运行目标用户代码。
* 调试:可以像在SIMICS中那样添加缓存模拟和循环计数器来进行调试 [3]。

## 7 可用性

QEMU可以在 http://bellard.org/qemu 上找到

## 參考文獻

* [1] Ian Piumarta, Fabio Riccardi, Optimizing direct threaded code by selective inlining, Proceedings of the 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI).
* [2] Mark Probst, Fast Machine-Adaptable Dynamic binary Translation, Workshop on Binary Translation 2001.
* [3] Peter S. Magnusson et al., SimICS/sun4m: A Virtual Workstation, Usenix Annual Technical Conference, June 15-18, 1998.
* [4] Kevin Lawton et al., the Bochs IA-32 Emulator Project, http://bochs.sourceforge.net.
* [5] The Free Software Foundation, the GNU Compiler Collection, http://gcc.gnu.org.
* [6] Julian Seward et al., Valgrind, an open-source memory debugger for x86-GNU/Linux, http://valgrind.kde.org/.
* [7] The BYTEmark benchmark program, BYTE Magazine, Linux version available at http://www.tux.org/˜mayer/linux/bmark.html.

## 註腳

* [註1] x86 cpu是指与Intel 80386处理器兼容的处理器。

* [註2] 这种模式现在已经被弃用了，因为它需要一个打了补丁的目标OS，而且目标OS可以访问主机QEMU地址空间。

* [註3] 为简单起见，QEMU实际上会为所有支持的cpu实现这种忽略代码缓存失效指令的行为。

* [註4] 在x86情况下，虚拟CPU无法获取确切的eflags寄存器，因为在某些情况下，由于条件代码优化，它不会被计算。这不是一个主要问题，因为在任何情况下，模拟代码仍然可以在同一点重新启动。

* [註5] 在撰写本文时，QEMU对线程的支持被认为是不成熟的，因为它的CPU核心模拟中存在锁定问题。
